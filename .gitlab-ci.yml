variables:
  GIT_SUBMODULE_STRATEGY: recursive
  PUSH_IMAGE: "true"
  BUILD_ARGS: "kafka sqlite"
  SCAN_IMAGE: "false"
  EXTRA_TAGS: "${CI_COMMIT_TAG}"

stages:
  # - secret_scanning
  # - sast
  # - sca
  - build_image
  - push_image
  - scan_image
  - deploy
  - dast_zap

# gitleaks:
#   stage: secret_scanning
#   image:
#     name: zricethezav/gitleaks
#     entrypoint: [""]
#   script:
#     - gitleaks dir . --verbose -f json -r gitleaks_detect_dir.json --exit-code 0
#     - gitleaks git . --verbose -f json -r gitleaks_detect_git.json --exit-code 0
#   allow_failure: true
#   artifacts:
#     when: always
#     paths:
#       - gitleaks_detect_dir.json
#       - gitleaks_detect_git.json

# njsscan:
#   stage: sast
#   needs: ["gitleaks"]
#   image: python
#   before_script:
#     - pip3 install --upgrade njsscan
#   script:
#     - njsscan . --exit-warning --sarif -o njsscan.sarif
#   allow_failure: true
#   artifacts:
#     when: always
#     paths:
#     - njsscan.sarif

# semgrep:
#   stage: sast
#   needs: ["gitleaks"]
#   image: returntocorp/semgrep
#   variables:
#     SEMGREP_RULES: p/javascript
#   script:
#     - semgrep ci --json --output semgrep.json
#   allow_failure: true
#   artifacts:
#     when: always
#     paths:
#     - semgrep.json

# sonarqube:
#   image: 
#       name: sonarsource/sonar-scanner-cli:11
#       entrypoint: [""]
#   variables:
#     SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"  # Defines the location of the analysis task cache
#     GIT_DEPTH: "0"  # Tells git to fetch all the branches of the project, required by the analysis task
#   stage: sast  
#   cache:
#     policy: pull-push
#     key: "sonar-cache-$CI_COMMIT_REF_SLUG"
#     paths:
#       - "${SONAR_USER_HOME}/cache"
#       - sonar-scanner/
#   script: 
#     - sonar-scanner -Dsonar.host.url="${SONAR_HOST_URL}"
#   allow_failure: true
  
# retire:
#   stage: sca
#   image: node:latest
#   needs: ["njsscan", "semgrep", "sonarqube"]
#   before_script:
#     - npm install -g retire
#   script:
#     - retire --outputformat cyclonedx --exitwith 0 --outputpath retirejs.xml
#   artifacts:
#     reports:
#       sast: retirejs.xml

docker-build:
  stage: build_image
  # needs: ["retire"]
  # image: docker
  # services:
  #   - name: docker:dind
  #     alias: docker
  # variables:
  #   DOCKER_IMAGE_NAME: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
  # before_script:
  #   - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  # # All branches are tagged with $DOCKER_IMAGE_NAME (defaults to commit ref slug)
  # # Default branch is also tagged with `latest`
  # script:
  #   - docker build --pull -t "$DOCKER_IMAGE_NAME" .
  #   - docker push "$DOCKER_IMAGE_NAME"
  #   - |
  #     if [[ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]]; then
  #       docker tag "$DOCKER_IMAGE_NAME" "$CI_REGISTRY_IMAGE:latest"
  #       docker push "$CI_REGISTRY_IMAGE:latest"
  #     fi
  # # Run this job in a branch where a Dockerfile exists
  # rules:
  #   - if: $CI_COMMIT_BRANCH
  #     exists:
  #       - Dockerfile
  image:
    name: gcr.io/kaniko-project/executor:v1.23.2-debug
    entrypoint: [""]
  # before_script:
  #   - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  script:
  - /kaniko/executor
    --context $CI_PROJECT_DIR
    --dockerfile $CI_PROJECT_DIR/Dockerfile
    --no-push
    --destination "${CI_REGISTRY_IMAGE}:${CI_COMMIT_TAG}"
    --tar-path ${CI_REGISTRY_IMAGE}.tar
  artifacts:
    paths:
    - image.tar
    when: on_success

docker-push:
  stage: push_image
  needs: ["docker-build"]
  image:
    name: gcr.io/go-containerregistry/crane:debug
    entrypoint: [""]
  script:
  - crane auth login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  - crane push image.tar "${CI_REGISTRY_IMAGE}:${CI_COMMIT_TAG}"

syft_sbom:
  stage: scan_image
  needs: ["docker-build"]
  image:
    name: registry.gitlab.com/gitlab-ci-utils/container-images/syft:latest
    entrypoint: [""]
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  script:
    - /syft/syft $CI_REGISTRY_IMAGE:latest -o cyclonedx-json=syft.cdx.json
  artifacts:
    paths:
      - syft.cdx.json
    reports:
      cyclonedx:
        - syft.cdx.json
  allow_failure: true

scan_image_trivy:
  stage: scan_image
  needs: ["docker-build"]
  image: docker:24
  services:
    - name: docker:24-dind
      alias: docker
  before_script:
    - apk --no-cache add curl python3 py3-pip
    - curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - docker pull "$CI_REGISTRY_IMAGE:latest"
    - trivy image "$CI_REGISTRY_IMAGE:latest"
  allow_failure: true
 
deploy:
  stage: deploy
  needs: ["scan_image_trivy", "syft_sbom"]
  before_script:
    - apk update && apk add openssh
    - apk add --no-cache --repository http://gr.archive.ubuntu.com/ubuntu sshpass
  script:
    - sshpass -p $AZURE_APPVM_PASS ssh -o StrictHostKeyChecking=no $AZURE_APPVM_USER@128.251.24.109 docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
    - sshpass -p $AZURE_APPVM_PASS ssh -o StrictHostKeyChecking=no $AZURE_APPVM_USER@128.251.24.109 docker run -it -d --rm -p 8080:8080 -p 8443:8443 "$CI_REGISTRY_IMAGE:latest" 

zap:
  stage: dast_zap
  needs: ["deploy"]
  image: owasp/zap2docker-stable:latest
  allow_failure: true
  script:
    - mkdir /zap/wrk
    - echo "Execute the baseline scan..."
    - /zap/zap-baseline.py -t https://10.0.0.3:8443/ -g gen.conf -r testreport.html
  after_script:
    - echo "Copy report file to the artifact path..."
    - cp /zap/wrk/testreport.html .
  artifacts:
    when: always
    paths:
      - testreport.html
