# This version of the pipeline uses STaaS instead of cosign

stages:
  # - secret_scanning
  # - sast
  # - sca
  - build_image
  # - sign_image
  - scan_image
  - attestations
  # - deploy
  # - dast_zap

################## secret_scanning ##################

# gitleaks:
#   stage: secret_scanning
#   image:
#     name: zricethezav/gitleaks
#     entrypoint: [""]
#   script:
#     - gitleaks dir . --verbose -f json -r gitleaks_detect_dir.json --exit-code 0
#     - gitleaks git . --verbose -f json -r gitleaks_detect_git.json --exit-code 0
#   allow_failure: true
#   artifacts:
#     when: always
#     paths:
#       - gitleaks_detect_dir.json
#       - gitleaks_detect_git.json

# ################## sast ##################

# njsscan:
#   stage: sast
#   needs: ["gitleaks"]
#   image: python
#   before_script:
#     - pip3 install --upgrade njsscan
#   script:
#     - njsscan . --exit-warning --sarif -o njsscan.sarif
#   allow_failure: true
#   artifacts:
#     when: always
#     paths:
#     - njsscan.sarif

# semgrep:
#   stage: sast
#   needs: ["gitleaks"]
#   image: returntocorp/semgrep
#   variables:
#     SEMGREP_RULES: p/javascript
#   script:
#     - semgrep ci --json --output semgrep.json
#   allow_failure: true
#   artifacts:
#     when: always
#     paths:
#     - semgrep.json

# sonarqube:
#   image: 
#       name: sonarsource/sonar-scanner-cli:11
#       entrypoint: [""]
#   variables:
#     SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"  # Defines the location of the analysis task cache
#     GIT_DEPTH: "0"  # Tells git to fetch all the branches of the project, required by the analysis task
#   stage: sast  
#   cache:
#     policy: pull-push
#     key: "sonar-cache-$CI_COMMIT_REF_SLUG"
#     paths:      
#       - "${SONAR_USER_HOME}/cache"
#       - sonar-scanner/
#   script: 
#     - sonar-scanner -Dsonar.host.url="${SONAR_HOST_URL}"
#   allow_failure: true

# ################## sca ##################
  
# retire:
#   stage: sca
#   image: node:latest
#   needs: ["njsscan", "semgrep", "sonarqube"]
#   before_script:
#     - npm install -g retire
#   script:
#     - retire --outputformat cyclonedx --exitwith 0 --outputpath retirejs.xml
#   artifacts:
#     reports:
#       sast: retirejs.xml

################## build_image ##################

kaniko-build:
  stage: build_image
  image:
    name: gcr.io/kaniko-project/executor:v1.23.2-debug
    entrypoint: [""]
  variables:
    RUNNER_GENERATE_ARTIFACTS_METADATA: "true"
  script:
    - /kaniko/executor
      --context "${CI_PROJECT_DIR}"
      --dockerfile "${CI_PROJECT_DIR}/Dockerfile"
      --destination "${CI_REGISTRY_IMAGE}:1.0.7"
      --image-name-with-digest-file tmp.hash
    - sed -n 's/.*@sha256:\([a-f0-9]\+\)/\1/p' tmp.hash > img.hash
  allow_failure: true
  artifacts:
    when: always
    paths:
      - img.hash
  rules:
    - if: $CI_COMMIT_BRANCH
      exists:
        - Dockerfile

# kaniko-build-unsigned:
#   stage: build_image
#   image:
#     name: gcr.io/kaniko-project/executor:v1.23.2-debug
#     entrypoint: [""]
#   variables:
#     RUNNER_GENERATE_ARTIFACTS_METADATA: "true"
#   script:
#     - /kaniko/executor
#       --context "${CI_PROJECT_DIR}"
#       --dockerfile "${CI_PROJECT_DIR}/Dockerfile"
#       --destination "${CI_REGISTRY_IMAGE}:unsigned"
#   allow_failure: true
#   rules:
#     - if: $CI_COMMIT_BRANCH
#       exists:
#         - Dockerfile

################## sign_image ##################

# In some cases, `cosign login` may not work (depends on the permissions of the tokens)
# If this is your case, use the next job which uses the docker image
# staas-sign-container-image:
#   stage: sign_image
#   # needs: ["kaniko-build"]
#   image: python:3.9
#   before_script:
#     - apt-get update && apt-get install jq -y
#     - curl -O -L "https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64"
#     - mv cosign-linux-amd64 cosign
#     - chmod +x cosign
#     - pip install requests
#     - echo $CI_REGISTRY_PASSWORD | ./cosign login registry.gitlab.com -u $CI_REGISTRY_USER --password-stdin=true 
#   script:
#     - export COMMENT=container-signature-$CI_PIPELINE_URL
#     - ./cosign generate "$CI_REGISTRY_IMAGE:1.0.7" > payload.json
#     - python3 staas-sign.py -t $STAAS_API_KEY -a payload.json -c $COMMENT -o payload.json.bundle -v
#     - cat payload.json | jq
#     - cat payload.json.bundle | jq
#     - jq -r '.base64Signature' ./payload.json.bundle > img.sig
#     - jq -r '.cert' ./payload.json.bundle | base64 -d > cert.pem
#     - COSIGN_EXPERIMENTAL=1 ./cosign attach signature "$CI_REGISTRY_IMAGE:1.0.7" --signature ./img.sig --payload ./payload.json --certificate-chain ./staas/ca.pem --certificate ./cert.pem  
#   after_script:
#     - COSIGN_EXPERIMENTAL=1 ./cosign verify "$CI_REGISTRY_IMAGE:1.0.7" --certificate-identity=$STAAS_EMAIL --certificate-oidc-issuer=https://staas.excid.io --certificate-chain ./staas/ca.pem --insecure-ignore-sct
#   allow_failure: true
#   artifacts:
#     when: always
#     paths:
#       - payload.json.bundle

# staas-sign-container-image:
#   stage: sign_image
#   needs: ["kaniko-build"]
#   image: docker:24
#   services:
#     - name: docker:24-dind
#       alias: docker
#   variables:
#     DOCKER_TLS_CERTDIR: ""
#   before_script:
#     # add binaries
#     - apk --no-cache add curl
#     - apk --no-cache add jq
#     # add cosign
#     - curl -O -L "https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64"
#     - mv cosign-linux-amd64 cosign
#     - chmod +x cosign
#     # add python & dependencies
#     - apk add python3
#     - curl -O https://bootstrap.pypa.io/get-pip.py    
#     - python3 get-pip.py --break-system-packages
#     - pip install requests --break-system-packages
#     # login to oci registry
#     - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
#   script:
#     - export COMMENT=container-signature-$CI_PIPELINE_URL
#     - ./cosign generate "$CI_REGISTRY_IMAGE:1.0.7" > payload.json
#     - python3 staas-sign.py -t $STAAS_API_KEY -a payload.json -c $COMMENT -o payload.json.bundle -v
#     - cat payload.json | jq
#     - cat payload.json.bundle | jq
#     - jq -r '.base64Signature' ./payload.json.bundle > img.sig
#     - jq -r '.cert' ./payload.json.bundle | base64 -d > cert.pem
#     - COSIGN_EXPERIMENTAL=1 ./cosign attach signature "$CI_REGISTRY_IMAGE:1.0.7" --signature ./img.sig --payload ./payload.json --certificate-chain ./staas/ca.pem --certificate ./cert.pem  
#   after_script:
#     - COSIGN_EXPERIMENTAL=1 ./cosign verify "$CI_REGISTRY_IMAGE:1.0.7" --certificate-identity=$STAAS_EMAIL --certificate-oidc-issuer=https://staas.excid.io --certificate-chain ./staas/ca.pem --insecure-ignore-sct
#   allow_failure: true
#   artifacts:
#     when: always
#     paths:
#       - payload.json.bundle

################## scan_image ##################

# trivy_scan:
#   stage: scan_image
#   needs: ["kaniko-build"]
#   image: docker:24
#   services:
#     - name: docker:24-dind
#       alias: docker
#   before_script:
#     - apk --no-cache add curl python3 py3-pip
#     - curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
#     - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
#   script:
#     - docker pull "$CI_REGISTRY_IMAGE:latest"
#     - trivy image "$CI_REGISTRY_IMAGE:latest"
#   allow_failure: true

trivy_sbom:
  stage: scan_image
  needs: ["kaniko-build"]
  image: docker:24
  services:
    - name: docker:24-dind
      alias: docker
  variables:
    DOCKER_TLS_CERTDIR: ""
    COSIGN_YES: "true"
  id_tokens:
    SIGSTORE_ID_TOKEN:
      aud: sigstore
  before_script:
    - apk --no-cache add curl
    # - apk --no-cache add jq
    - curl -O -L "https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64"
    - mv cosign-linux-amd64 cosign
    - chmod +x cosign
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    - apk --no-cache add python3 py3-pip
    - curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
  script:
    - docker pull "$CI_REGISTRY_IMAGE:1.0.7"
    - trivy image --format cyclonedx -o image.sbom.json "$CI_REGISTRY_IMAGE:1.0.7"
  allow_failure: true
  artifacts:
    when: always
    paths:
      - image.sbom.json
 

################## attestation ##################

# staas-provenance:
#   stage: attestations
#   needs: ["kaniko-build"]
#   image: python:3.9
#   before_script:
#     - apt-get update && apt-get install jq -y
#     - curl -O -L "https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64"
#     - mv cosign-linux-amd64 cosign
#     - chmod +x cosign
#     - pip install requests
#   script: # image.prov.json is an in-toto statment, a provenance document about the container image
#     - cat artifacts-metadata.json
#     - |
#       export IMG_HASH_B64=$(cat img.hash | base64 -w 0)
#       jq --arg b64hash "$IMG_HASH_B64" --arg imgname "$CI_REGISTRY_IMAGE" '.subject = [{"name":$imgname, "digest":{"sha256":$b64hash}}]' artifacts-metadata.json > image.prov.json
#     - export COMMENT=provenance
#     - python3 staas-upload.py image.prov.json $STAAS_API_TOKEN $COMMENT
#   after_script:
#     - ./cosign verify-blob --certificate-identity=$STAAS_EMAIL --certificate-oidc-issuer=https://staas.excid.io --certificate-chain ca.pem --insecure-ignore-sct --bundle image.prov.json.bundle image.prov.json
#   allow_failure: true
#   artifacts:
#     when: always
#     paths:
#       - image.prov.json.bundle

staas-sbom:
  stage: attestations
  needs: ["trivy_sbom", "kaniko-build"]
  image: python:3.9
  before_script:
    - curl -O -L "https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64"
    - mv cosign-linux-amd64 cosign
    - chmod +x cosign
    - pip install requests
  script:
    # for sbom attestation: 1. generate sbom 2. make in-toto statement 3. hash & sign 4. craft dsse envelope
    # 1 was done in trivy-sbom job
    # 2. craft in-toto statement
    - ls
    - cat img.hash
    - cat stass/intoto-schema.json

    - python3 craft-intoto.py -f staas/intoto-schema.json -n $CI_REGISTRY_IMAGE -d $(echo img.hash) -s image.sbom.json  # outputs sbom-intoto.json
    - cat sbom-intoto.json | jq
    # 3. sign w/ staas
    - export COMMENT=sbom-attestation-$CI_PIPELINE_URL
    - python3 staas-sign.py -t $STAAS_API_KEY -a sbom-intoto.json -c $COMMENT -o sbom-intoto.json.bundle -v  
    - cat sbom-intoto.json.bundle | jq
    # 4. craft dsse envelope and attach
    - jq -r '.base64Signature' ./sbom-intoto.json.bundle > img.sig
    
    - COSIGN_EXPERIMENTAL=1 ./cosign attach attestation --attestation ./ "$CI_REGISTRY_IMAGE:1.0.7" 
  # after_script:
    # - COSIGN_EXPERIMENTAL=1 ./cosign verify "$CI_REGISTRY_IMAGE:1.0.7" --certificate-identity=$STAAS_EMAIL --certificate-oidc-issuer=https://staas.excid.io --certificate-chain ./staas/ca.pem --insecure-ignore-sct
  allow_failure: true
  artifacts:
    when: always
    paths:
      - image.sbom.json.bundle


################## deploy ##################

# deploy:
#   stage: deploy
#   needs: ["staas-sbom", "staas-provenance"]
#   before_script:
#     - echo "deb http://gr.archive.ubuntu.com/ubuntu ubnt main" >> /etc/apt/sources.list
#     - apt-get update && apt-get install openssh
#     - apt-get install sshpass
#   script:
#     - sshpass -p $AZURE_APPVM_PASS ssh -o StrictHostKeyChecking=no $AZURE_APPVM_USER@$APP_VM_IP docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
#     - sshpass -p $AZURE_APPVM_PASS ssh -o StrictHostKeyChecking=no $AZURE_APPVM_USER@$APP_VM_IP docker run -it -d --rm -p 8080:8080 -p 8443:8443 "$CI_REGISTRY_IMAGE:latest" 

################## dast_zap ##################

# zap:
#   stage: dast_zap
#   needs: ["deploy"]
#   image: 
#     name: ghcr.io/zaproxy/zaproxy:stable
#   allow_failure: true
#   before_script:
#     - mkdir /zap/wrk
#   script:
#     - /zap/zap-full-scan.py -t https://128.251.24.109:8443/ -g gen.conf -r zapreport.html -I
#     - cp /zap/wrk/zapreport.html zapreport.html
#   artifacts:
#     when: always
#     paths:
#       - zapreport.html
